/**
 * æ–¹æ¡ˆ 6: è‡ªå­¦ä¹ è¯­ä¹‰ç¼“å­˜è·¯ç”± (Self-Learning Semantic Cache)
 * 
 * ã€åŸå› ã€‘
 * è·¯ç”±é€»è¾‘ï¼ˆç‰¹åˆ«æ˜¯ LLM è·¯ç”±ï¼‰å¾€å¾€å­˜åœ¨é‡å¤æ€§ã€‚å¤§é‡ç”¨æˆ·å¯èƒ½ä¼šé—®ç±»ä¼¼çš„é—®é¢˜ã€‚é‡å¤è°ƒç”¨å¤§æ¨¡å‹ä¸ä»…æ˜‚è´µï¼Œè€Œä¸”å¢åŠ äº†å“åº”å»¶è¿Ÿã€‚
 * 
 * ã€ç›®æ ‡ã€‘
 * å®ç°åŸºäºè¯­ä¹‰ç›¸ä¼¼åº¦çš„ç¼“å­˜æœºåˆ¶ã€‚å³ä½¿ä¸¤ä¸ªé—®é¢˜çš„æ–‡å­—ä¸å®Œå…¨ä¸€è‡´ï¼ˆå¦‚â€œæ€ä¹ˆå¼€ç¥¨â€å’Œâ€œæˆ‘è¦å‘ç¥¨â€ï¼‰ï¼Œä¹Ÿèƒ½é€šè¿‡å‘é‡åŒ¹é…å‘½ä¸­ç¼“å­˜ã€‚
 * 
 * ã€ç»“æœã€‘
 * 1. å‘½ä¸­ç¼“å­˜çš„è¯·æ±‚å“åº”é€Ÿåº¦æå‡ 100 å€ï¼ˆä»æ•°ç§’ç¼©çŸ­è‡³æ•°æ¯«ç§’ï¼‰ã€‚
 * 2. æå¤§èŠ‚çœäº† API è°ƒç”¨æˆæœ¬ã€‚
 * 3. å…·å¤‡â€œè‡ªåŠ¨çƒ­åŠ è½½â€åŠŸèƒ½ï¼Œæ–°è¯†åˆ«çš„è·¯ç”±ç»“æœä¼šè‡ªåŠ¨åŠ å…¥ç¼“å­˜æ± ã€‚
 * 
 * ã€å¯è¿›ä¸€æ­¥æå‡çš„åœ°æ–¹ã€‘
 * 1. å¼•å…¥ç¼“å­˜è¿‡æœŸç­–ç•¥ï¼ˆTTLï¼‰å’Œæƒé‡æœºåˆ¶ï¼šé«˜é¢‘å‘½ä¸­é¡¹æ°¸ä¹…ä¿ç•™ï¼Œä½é¢‘é¡¹å®šæœŸæ¸…ç†ã€‚
 * 2. åˆ†å¸ƒå¼ç¼“å­˜åŒæ­¥ï¼šåœ¨å¤šèŠ‚ç‚¹éƒ¨ç½²ç¯å¢ƒä¸‹ï¼Œç¡®ä¿å„èŠ‚ç‚¹çš„ç¼“å­˜çŠ¶æ€åŒæ­¥ã€‚
 */
const { cosineSimilarity, getEmbedding } = require('./utils');
require('dotenv').config();

// æ¨¡æ‹Ÿå¤–éƒ¨å­˜å‚¨ (å¦‚ Redis + Vector Plugin)
let SEMANTIC_CACHE = [
  { query: 'å¦‚ä½•å¼€å…·å‘ç¥¨', vector: null, route: 'BILLING' },
  { query: 'ç³»ç»Ÿæ— æ³•å¯åŠ¨ï¼Œæç¤º 404 é”™è¯¯', vector: null, route: 'TECHNICAL' }
];

/**
 * ç¼“å­˜è‡ªåŠ¨å¡«å…… (Cache Hydration)
 * å°†æ–°è¯†åˆ«çš„ç»“æœè‡ªåŠ¨åŠ å…¥ç¼“å­˜æ± ï¼Œä¾›åç»­ä½¿ç”¨
 */
async function hydrateCache(query, route) {
  console.log(`âœ¨ [ç¼“å­˜æ›´æ–°] æ­£åœ¨ä¸ºæ–°æŸ¥è¯¢ "${query}" ç”Ÿæˆå‘é‡å¹¶å­˜å…¥ç¼“å­˜...`);
  const vector = await getEmbedding(query);
  SEMANTIC_CACHE.push({ query, vector, route });
}

async function cachedRoute(input) {
  /**
   * ğŸ› ï¸ ä¼ä¸šçº§é˜ˆå€¼æƒè¡¡ (Threshold Insight):
   * 
   * 1. ä¸ºä»€ä¹ˆæ˜¯ 0.95 è€Œä¸æ˜¯ 0.85ï¼Ÿ
   *    - ç¼“å­˜(Cache)è¿½æ±‚çš„æ˜¯ã€ç²¾å‡†åº¦ (Precision)ã€‘ã€‚ç”±äºç¼“å­˜å‘½ä¸­åé€šå¸¸ä¼šç»•è¿‡åç»­æ‰€æœ‰éªŒè¯é€»è¾‘ï¼Œä¸€æ—¦è¯¯åˆ¤ï¼Œ
   *      é”™è¯¯ä¼šç”±äºç¼“å­˜æœºåˆ¶è€ŒæŒç»­å‘ç”Ÿã€‚å› æ­¤è®¾å®šæé«˜é˜ˆå€¼(0.95+)ï¼Œå®å¯ä¸å‘½ä¸­èµ°æ…¢é€Ÿè·¯å¾„ï¼Œä¹Ÿç»ä¸å®¹è®¸â€œå¼ å† ææˆ´â€ã€‚
   *    - è·¯ç”±(Router)è¿½æ±‚çš„æ˜¯ã€å¬å›ç‡ (Recall)ã€‘ã€‚è·¯ç”±åé€šå¸¸è¿˜æœ‰ LLM æˆ–å·¥å…·é€»è¾‘è¿›è¡ŒäºŒæ¬¡å¤„ç†ï¼Œæœ‰ä¸€å®šçš„å®¹é”™ç©ºé—´ï¼Œ
   *      å› æ­¤é€šå¸¸è®¾å®šåœ¨ 0.80 - 0.90 ä¹‹é—´ã€‚
   * 
   * 2. æ€§èƒ½æç¤ºï¼š
   *    - åœ¨ç”Ÿäº§ç¯å¢ƒä¸‹ï¼Œè¿™ä¸€æ­¥é€šå¸¸ç”± Redis çš„å‘é‡æœç´¢åŠŸèƒ½(å¦‚ RedisVL)åœ¨æ¯«ç§’çº§å®Œæˆï¼Œè€Œä¸æ˜¯åœ¨ JS ä¸­å¾ªç¯å¯¹æ¯”ã€‚
   */
  const HIT_THRESHOLD = 0.95; 
  console.log(`\n--- è·¯ç”±æ£€ç´¢: "${input}" ---`);

  const inputVec = await getEmbedding(input);
  
  for (const item of SEMANTIC_CACHE) {
    const score = cosineSimilarity(inputVec, item.vector);
    if (score >= HIT_THRESHOLD) {
      console.log(`ğŸš€ [è¯­ä¹‰ç¼“å­˜å‘½ä¸­] ä¸ç°æœ‰è®°å½• "${item.query}" ç›¸ä¼¼åº¦: ${score.toFixed(4)}`);
      return item.route;
    }
  }

  console.log(`ğŸ¢ [æœªå‘½ä¸­ç¼“å­˜] æ‰§è¡Œå®Œæ•´è·¯ç”±é€»è¾‘ (æ¨¡æ‹Ÿ)...`);
  const result = 'SALES'; // æ¨¡æ‹Ÿè¯†åˆ«ç»“æœ
  await hydrateCache(input, result);
  return result;
}

async function main() {
  console.log('--- ä¼ä¸šçº§æ–¹æ¡ˆ 6: è¯­ä¹‰ç¼“å­˜ (å¸¦è‡ªåŠ¨æ›´æ–°åŠŸèƒ½) ---');
  
  // åˆå§‹åŒ–
  for (const item of SEMANTIC_CACHE) {
    item.vector = await getEmbedding(item.query);
  }
  
  await cachedRoute('è½¯ä»¶å¯åŠ¨ä¸äº†ï¼ŒæŠ¥ 404'); // å‘½ä¸­
  await cachedRoute('æˆ‘æƒ³ä¹°ä½ ä»¬çš„ä¼šå‘˜');    // æœªå‘½ä¸­ -> è‡ªåŠ¨åŠ å…¥ç¼“å­˜
  await cachedRoute('æˆ‘æƒ³ä¹°ä½ ä»¬çš„ä¼šå‘˜');    // å†æ¬¡æŸ¥è¯¢ -> å‘½ä¸­ï¼
}

main().catch(console.error);
